'''
Created on Dec 29, 2013

@author: tariktosun
'''
import unittest
import Embedding.Node as Node
#import Embedding.Edge as Edge
import Embedding.Design as Design
from Embedding import Embedding

class Test_Embedding(unittest.TestCase):
     
    def setUp(self):
        ''' define fixtures for tests. '''
        # Type subsumption:
        #valid_types = [1, 2]
        self.types_subsumed = {1: [1,2], 2: [2]}
        
        # Designs:
        b = [0]*4
        a = [0]*6
        c = [0]*5
        for i in xrange(len(b)):
            b[i] = Node.Node(str(i))
            b[i].type = 2
        for i in xrange(len(a)):
            a[i] = Node.Node(str(i))
            a[i].type = 2
        for i in xrange(len(c)):
            c[i] = Node.Node(str(i))
            c[i].type = 2
        # build structure:
        # subdesign:
        b[3].add_child(b[2])
        b[2].add_child(b[1])
        b[2].add_child(b[0])
        #
        b[1].is_end_effector = True
        b[0].is_end_effector = True
        # superdesign (good)
        a[5].add_child(a[4])
        a[4].add_child(a[3])
        a[4].add_child(a[2])
        a[3].add_child(a[1])
        a[2].add_child(a[0])
        #
        a[0].is_end_effector = True
        a[1].is_end_effector = True
        #superdesign (violates PVD in one case)
        c[4].add_child(c[3])
        c[3].add_child(c[2])
        c[2].add_child(c[1])
        c[2].add_child(c[0])
        #
        c[1].is_end_effector = True
        c[0].is_end_effector = True
        
        # Store as class variables:
        self.B = Design.Design(b[3], b)
        self.A = Design.Design(a[5], a)
        self.AB_nodemap = {b[0]:a[0],
                        b[1]:a[1],
                        b[2]:a[4],
                        b[3]:a[5],
                        }
        self.C = Design.Design(c[4], c)
        self.CB_nodemap = {b[3]:c[4],
                           b[2]:c[3],
                           b[1]:c[1],
                           b[0]:c[0],
                           }
        
        # reverse maps:
        self.AB_reversemap = dict (zip(self.AB_nodemap.values(),self.AB_nodemap.keys()))
        self.CB_reversemap = dict (zip(self.CB_nodemap.values(),self.CB_nodemap.keys()))
        
        # problematic nodemap for CB generated by (problematic) brute force:
        self.CB_problematic_map = {b[3]:c[4],
                               b[2]:c[3],
                               b[1]:c[2],
                               b[0]:c[1],
                               }
        
        # Problematic AB map which maps B's end effectors to A nodes with children.
        self.AB_fails_ee = {b[0]:a[2],
                        b[1]:a[3],
                        b[2]:a[4],
                        b[3]:a[5],
                        }
        
    def tearDown(self):
        pass
    
    def test_topological_embedding_dynamic(self):
        ''' NOTE: This test contains some functionality manipulations!!!'''
        
        ''' Swap functionality around to perform tests:'''
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed)
        
        self.B.nodes[2].type = 1
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert not embedding.check_topological_embedding_dynamic(), 'Functionality fail set ' + str(i)
        self.A.nodes[4].type = 1
        self.C.nodes[2].type = 1
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert embedding.check_topological_embedding_dynamic(), 'Functionality pass set ' + str(i)
        self.B.nodes[2].type = 2
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert embedding.check_topological_embedding_dynamic(), 'Functionality pass set ' + str(i)        
              
        ''' Change functionality back, and continue tests as usual. '''
        self.A.nodes[4].type = 2
        self.C.nodes[2].type = 2
        self.B.nodes[2].type = 2
        
        # pass set:
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed)
        pass_set = [AB_embedding, CB_embedding ]
        #pass_set = [ CB_embedding ]
        #pass_set = [AB_embedding]

        # fail set:
        BA_embedding = Embedding.Embedding(self.B, self.A, self.types_subsumed)
        BC_embedding = Embedding.Embedding(self.B, self.C, self.types_subsumed)
        fail_set = [ BA_embedding, BC_embedding ]

        
        for i, embedding in enumerate(pass_set):
            assert embedding.check_topological_embedding_dynamic(), 'Pass set ' + str(i)
            assert embedding.check_vertex2vertex(), 'Pass set ' + str(i)
            assert embedding.check_edge2path(), 'Pass set ' + str(i)
            assert embedding.check_vertex_disjointness(), 'Pass set ' + str(i)
            
        for i, embedding in enumerate(fail_set):
            assert not embedding.check_topological_embedding_dynamic(), 'Fail set ' + str(i)
    
    def test_topological_embedding_brute(self):
        ''' NOTE: This test contains some functionality manipulations!!!'''
        
        ''' Swap functionality around to perform tests:'''
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed)
        
        self.B.nodes[2].type = 1
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert not embedding.check_topological_embedding_brute(), 'Functionality fail set ' + str(i)
        self.A.nodes[4].type = 1
        self.C.nodes[2].type = 1
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert embedding.check_topological_embedding_brute(), 'Functionality pass set ' + str(i)
        self.B.nodes[2].type = 2
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert embedding.check_topological_embedding_brute(), 'Functionality pass set ' + str(i)        
              
        ''' Change functionality back, and continue tests as usual. '''
        self.A.nodes[4].type = 2
        self.C.nodes[2].type = 2
        self.B.nodes[2].type = 2
        
        # pass set:
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed)
        pass_set = [AB_embedding, CB_embedding] # There is actually a valid CB embedding.

        # fail set:
        BA_embedding = Embedding.Embedding(self.B, self.A, self.types_subsumed)
        BC_embedding = Embedding.Embedding(self.B, self.C, self.types_subsumed)
        fail_set = [ BA_embedding, BC_embedding]

        
        for i, embedding in enumerate(pass_set):
            assert embedding.check_topological_embedding_brute(), 'Pass set ' + str(i)
            assert embedding.check_vertex2vertex(), 'Pass set ' + str(i)
            assert embedding.check_edge2path(), 'Pass set ' + str(i)
            assert embedding.check_vertex_disjointness(), 'Pass set ' + str(i)
            
        for i, embedding in enumerate(fail_set):
            assert not embedding.check_topological_embedding_brute(), 'Fail set ' + str(i)
        

    def test_vertex2vertex(self):
        ''' NOTE: This test contains some functionality manipulations!!!'''
        
        ''' Swap functionality around to perform tests:'''
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed, self.AB_nodemap)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed, self.CB_nodemap)
        
        self.B.nodes[2].type = 1
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert not embedding.check_vertex2vertex(), 'Functionality fail set ' + str(i)
        self.A.nodes[4].type = 1
        self.C.nodes[3].type = 1
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert embedding.check_vertex2vertex(), 'Functionality pass set ' + str(i)
        self.B.nodes[2].type = 2
        for i, embedding in enumerate([ AB_embedding, CB_embedding ]):
            assert embedding.check_vertex2vertex(), 'Functionality pass set ' + str(i)        
              
        ''' Change functionality back, and continue tests as usual. '''
        self.A.nodes[4].type = 2
        self.C.nodes[3].type = 2
        self.B.nodes[2].type = 2
        
        # pass set:
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed, self.AB_nodemap)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed, self.CB_nodemap)
        AB_fails_ee = Embedding.Embedding(self.A, self.B, self.types_subsumed, self.AB_fails_ee)
        pass_set = [ AB_embedding, CB_embedding ]

        # fail set:
        BA_embedding = Embedding.Embedding(self.B, self.A, self.types_subsumed, self.AB_reversemap)
        BC_embedding = Embedding.Embedding(self.B, self.C, self.types_subsumed, self.CB_reversemap)
        fail_set = [ BA_embedding, BC_embedding, AB_fails_ee ]
        
        for i, embedding in enumerate(pass_set):
            assert embedding.check_vertex2vertex(), 'Pass set ' + str(i)
            
        for i, embedding in enumerate(fail_set):
            assert not embedding.check_vertex2vertex(), 'Fail set' + str(i)
        
    def test_edge2path(self):
        # pass set:
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed, self.AB_nodemap)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed, self.CB_nodemap)
        AB_fails_ee = Embedding.Embedding(self.A, self.B, self.types_subsumed, self.AB_fails_ee)
        pass_set = [AB_embedding, CB_embedding, AB_fails_ee]

        # fail set:
        #BA_embedding = Embedding.Embedding(self.B, self.A, self.AB_reversemap)
        #BC_embedding = Embedding.Embedding(self.B, self.C, self.CB_reversemap)
        #fail_set = [ BA_embedding, BC_embedding ]
        fail_set = []
        
        for i, embedding in enumerate(pass_set):
            assert embedding.check_edge2path(), 'Pass set ' + str(i)
            
        for i, embedding in enumerate(fail_set):
            assert not embedding.check_edge2path(), 'Fail set ' + str(i)
        #assert self.check_edge2path(self.A, self.B, self.AB_nodemap)
        
    def test_vertex_disjointness(self):
        # pass set:
        AB_embedding = Embedding.Embedding(self.A, self.B, self.types_subsumed, self.AB_nodemap)
        CB_embedding = Embedding.Embedding(self.C, self.B, self.types_subsumed, self.CB_nodemap)
        CB_problematic = Embedding.Embedding(self.C, self.B, self.types_subsumed, self.CB_problematic_map)
        AB_fails_ee = Embedding.Embedding(self.A, self.B, self.types_subsumed, self.AB_fails_ee)
        
        pass_set = [AB_embedding, AB_fails_ee]

        # fail set:
        #BA_embedding = Embedding.Embedding(self.B, self.A, self.AB_reversemap)
        #BC_embedding = Embedding.Embedding(self.B, self.C, self.CB_reversemap)
        #fail_set = [ BA_embedding, BC_embedding ]
        
        fail_set = [CB_embedding, CB_problematic]
        
        for i, embedding in enumerate(pass_set):
            assert embedding.check_vertex_disjointness(), 'Pass set ' + str(i)
            
        for i, embedding in enumerate(fail_set):
            assert not embedding.check_vertex_disjointness(), 'Fail set ' + str(i)
        
        
if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()