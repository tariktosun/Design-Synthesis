'''
Created on Jan 14, 2014

@author: tariktosun
'''
import Embedding.Node as Node
#import Embedding.Edge as Edge
import Embedding.Design as Design


def setUpTopologyFixtures(test_object):
    '''
    Sets up fixtures for the test class given as arg.
    '''
    # Type subsumption:
    #valid_types = [1, 2]
    types_subsumed = {1: [1,2], 2: [2]}
    length_scaling = 1
    test_object.params = {'types_subsumed': types_subsumed,
                   'length_scaling': length_scaling}
    
    # Designs:
    b = [0]*4
    a = [0]*6
    c = [0]*5
    for i in xrange(len(b)):
        b[i] = Node.Node(str(i))
        b[i].type = 2
    for i in xrange(len(a)):
        a[i] = Node.Node(str(i))
        a[i].type = 2
    for i in xrange(len(c)):
        c[i] = Node.Node(str(i))
        c[i].type = 2
    # build structure:
    # subdesign:
    b[3].add_child(b[2])
    b[2].add_child(b[1])
    b[2].add_child(b[0])
    #
    b[1].is_end_effector = True
    b[0].is_end_effector = True
    # superdesign (good)
    a[5].add_child(a[4])
    a[4].add_child(a[3])
    a[4].add_child(a[2])
    a[3].add_child(a[1])
    a[2].add_child(a[0])
    #
    a[0].is_end_effector = True
    a[1].is_end_effector = True
    #superdesign (violates PVD in one case)
    c[4].add_child(c[3])
    c[3].add_child(c[2])
    c[2].add_child(c[1])
    c[2].add_child(c[0])
    #
    c[1].is_end_effector = True
    c[0].is_end_effector = True
    
    # Store as class variables:
    test_object.B = Design.Design(b[3], b)
    test_object.A = Design.Design(a[5], a)
    test_object.AB_nodemap = {b[0]:a[0],
                    b[1]:a[1],
                    b[2]:a[4],
                    b[3]:a[5],
                    }
    test_object.C = Design.Design(c[4], c)
    test_object.CB_nodemap = {b[3]:c[4],
                       b[2]:c[3],
                       b[1]:c[1],
                       b[0]:c[0],
                       }
    
    # reverse maps:
    test_object.AB_reversemap = dict (zip(test_object.AB_nodemap.values(),test_object.AB_nodemap.keys()))
    test_object.CB_reversemap = dict (zip(test_object.CB_nodemap.values(),test_object.CB_nodemap.keys()))
    
    # problematic nodemap for CB generated by (problematic) brute force:
    test_object.CB_problematic_map = {b[3]:c[4],
                           b[2]:c[3],
                           b[1]:c[2],
                           b[0]:c[1],
                           }
    
    # Problematic AB map which maps B's end effectors to A nodes with children.
    test_object.AB_fails_ee = {b[0]:a[2],
                    b[1]:a[3],
                    b[2]:a[4],
                    b[3]:a[5],
                    }
    return